#version 320 es

precision highp float;

layout (vertices = 4) out;

#define ID gl_InvocationID

in VertexData {
    vec2 first_ctrl;
    vec2 second_ctrl;
} v_in[];

uniform float aa_width;

patch out PatchData {
    vec2 ctrl1;
    vec2 ctrl2;
    int type;
} patch_data;

const float ZERO = 0.0f;
const float HALF = 0.5f;
const float ONE = 1.0f;
const float THREE = 3.0f;

const float tessel_x_factor = 0.0001;

void main(){
    if (ID == 0){

        // control points in screen coordinates
        patch_data.ctrl1 = gl_in[0].gl_Position.xy + v_in[0].second_ctrl;
        patch_data.ctrl2 = gl_in[1].gl_Position.xy + v_in[1].first_ctrl;

        // patch type
        if(gl_in[0].gl_Position == gl_in[1].gl_Position){
            patch_data.type = 1;
        } else {
            patch_data.type = 0;
        }

        // tesselation along the length of spline
        float tessel_x;
        {
            vec2 line = gl_in[1].gl_Position.xy - gl_in[0].gl_Position.xy;
            float line_dot = dot(line, line);
            tessel_x = floor(length(line) * (
                length(gl_in[0].gl_Position.xy + line * (dot(patch_data.ctrl1 - gl_in[0].gl_Position.xy, line) / line_dot) - patch_data.ctrl1)
              + length(gl_in[0].gl_Position.xy + line * (dot(patch_data.ctrl2 - gl_in[0].gl_Position.xy, line) / line_dot) - patch_data.ctrl2)
                ) * tessel_x_factor) + ONE;
        }

        // tesselation along the width of spline
        float tessel_y = (aa_width == ZERO ? ONE : THREE);

        gl_TessLevelInner[0] = tessel_x;
        gl_TessLevelInner[1] = tessel_y;

        gl_TessLevelOuter[0] = tessel_y;
        gl_TessLevelOuter[1] = tessel_x;
        gl_TessLevelOuter[2] = tessel_y;
        gl_TessLevelOuter[3] = tessel_x;
    }

    gl_out[ID].gl_Position = gl_in[ID].gl_Position;
}
