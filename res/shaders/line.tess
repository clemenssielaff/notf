#version 320 es

precision highp float;

layout (vertices = 4) out;

#define ID gl_InvocationID

in VertexData {
    vec2 first_ctrl;
    vec2 second_ctrl;
} v_in[];

uniform float aa_width;

patch out PatchData {
    float ctrl1_length;
    float ctrl2_length;
    vec2 ctrl1_direction;
    vec2 ctrl2_direction;
    int type;
} patch_data;

const float ZERO = 0.0f;
const float HALF = 0.5f;
const float ONE = 1.0f;
const float THREE = 3.0f;

const float tessel_x_factor = 0.0001;
const float tessel_x_max = 64.0;

void main(){
    if (ID == 0){

        // ctrl point delta magnitude
        patch_data.ctrl1_length = max(ZERO, length(v_in[0].second_ctrl) - ONE);
        patch_data.ctrl2_length = max(ZERO, length(v_in[1].first_ctrl) - ONE);

        // control points in screen coordinates
        patch_data.ctrl1_direction = normalize(v_in[0].second_ctrl);
        patch_data.ctrl2_direction = normalize(v_in[1].first_ctrl);

        // bezier spline points
        #define start (gl_in[0].gl_Position.xy)
        #define end (gl_in[1].gl_Position.xy)
        vec2 ctrl1 = start + (patch_data.ctrl1_direction * patch_data.ctrl1_length);
        vec2 ctrl2 = end + (patch_data.ctrl2_direction * patch_data.ctrl2_length);

//        // patch type
//        if(gl_in[0].gl_Position == gl_in[1].gl_Position){
//            if (v_in[1].first_ctrl == vec2(ZERO, ZERO) && v_in[1].second_ctrl == vec2(ZERO, ZERO)){
//                patch_data.type = 2; // start cap
//            } else if (v_in[0].first_ctrl == vec2(ZERO, ZERO) && v_in[0].second_ctrl == vec2(ZERO, ZERO)){
//                patch_data.type = 3; // end cap
//            } else {
//                patch_data.type = 1; // joint
//            }
//        } else {
//            patch_data.type = 0; // normal segment
//        }

        // tesselation along the length of spline
        float tessel_x;
        {
            vec2 line = end - start;
            float line_dot = dot(line, line);
            tessel_x = min(tessel_x_max,
                           floor(length(line) * (
                                     length(start + line * (dot(ctrl1 - start, line) / line_dot) - ctrl1) +
                                     length(start + line * (dot(ctrl2 - start, line) / line_dot) - ctrl2)
                                     ) * tessel_x_factor) + ONE);
        }

        // tesselation along the width of spline
        float tessel_y = (aa_width == ZERO ? ONE : THREE);

        gl_TessLevelInner[0] = tessel_x;
        gl_TessLevelInner[1] = tessel_y;

        gl_TessLevelOuter[0] = tessel_y;
        gl_TessLevelOuter[1] = tessel_x;
        gl_TessLevelOuter[2] = tessel_y;
        gl_TessLevelOuter[3] = tessel_x;
    }

    gl_out[ID].gl_Position = gl_in[ID].gl_Position;
}
