// This file is auto-generated by CMake at configuration time from ./config.hpp.in
#pragma once

// compiler related ================================================================================================= //

/// Operating System (as determined by CMake)
#cmakedefine NOTF_LINUX
#cmakedefine NOTF_WINDOWS
#cmakedefine NOTF_MACINTOSH

/// Compiler used (as determined by CMake).
#cmakedefine NOTF_CLANG
#cmakedefine NOTF_GCC
#cmakedefine NOTF_MSVC

/// Build type.
#cmakedefine NOTF_DEBUG
#cmakedefine NOTF_TEST
#cmakedefine NOTF_RELEASE

// notf namespace =================================================================================================== //

/// Opens the notf namespace.
#define NOTF_OPEN_NAMESPACE namespace @NOTF_NAMESPACE_NAME@ {

/// For visual balance with NOTF_OPEN_NAMESPACE.
#define NOTF_CLOSE_NAMESPACE }

/// Use the notf namespace.
#define NOTF_USING_NAMESPACE using namespace @NOTF_NAMESPACE_NAME@

// notf::literals namespace ========================================================================================= //

/// Opens the notf::literals namespace.
#define NOTF_OPEN_LITERALS_NAMESPACE inline namespace @NOTF_LITERALS_NAMESPACE_NAME@ {

/// For visual balance with NOTF_OPEN_LITERALS_NAMESPACE.
#define NOTF_CLOSE_LITERALS_NAMESPACE }

/// Use the notf::literals namespace.
#define NOTF_USING_LITERALS using namespace ::@NOTF_NAMESPACE_NAME@::@NOTF_LITERALS_NAMESPACE_NAME@

// notf constants =================================================================================================== //

/// Minimum log level for log messages to be compiled.
/// Log messages that are logged with NOTF_LOG_x() where "x" has  a level less than NOTF_LOG_LEVEL are removed before
/// compilation.
///     TRACE = 0
///     DEBUG = 1
///     INFO  = 2
///     WARN  = 3
///     ERROR = 4
///     CRIT  = 5
#define NOTF_LOG_LEVEL @NOTF_LOG_LEVEL@

// notf configuration =============================================================================================== //

NOTF_OPEN_NAMESPACE

namespace config {

/// Version of the notf source code.
constexpr auto version_major() noexcept { return @PROJECT_VERSION_MAJOR@; };
constexpr auto version_minor() noexcept { return @PROJECT_VERSION_MINOR@; };
constexpr auto version_patch() noexcept { return @PROJECT_VERSION_PATCH@; };

/// Human readable notf version string.
constexpr const char* version_string() noexcept { return "@NOTF_VERSION_STRING@"; }

/// The git commit from which the binary was compiled.
constexpr const char* built_from_commit() noexcept { return "@NOTF_BUILT_COMMIT@"; }

/// Whether or not the code was modified before compilation.
constexpr bool was_commit_modified() noexcept { return @NOTF_BUILT_COMMIT_WAS_MODIFIED@; }

/// Whether or not a failed assertion will immediately call `std::abort` or just throw an exception.
constexpr bool abort_on_assert() noexcept
{
#ifdef NOTF_TEST // never abort during tests
    return 0;
#else
    return @NOTF_ABORT_ON_ASSERT@;
#endif
}

/// System endianess
constexpr bool is_big_endian() noexcept { return @NOTF_IS_BIG_ENDIAN@; }

/// Seed value used for all hashing at compile time.
/// Although it is highly unlikely to have a hash collision, it is still possible that (for example) two property names
/// produce the same hash value. Since this would cause the built to fail, you can manually set this seed value to
/// anything != 0 (the default) and try again. Chances are, you'll get lucky on your second try.
constexpr auto constexpr_seed() noexcept { return 0; }

} // namespace config

NOTF_CLOSE_NAMESPACE
